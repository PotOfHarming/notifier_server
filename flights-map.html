<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plane Locations Map</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #map {
            flex: 1;
            filter: grayscale(70%);
        }
        .info-panel {
            padding: 10px;
            background: #f0f0f0;
            border-top: 1px solid #ccc;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        .status {
            font-size: 14px;
        }
        .range-filter {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 13px;
            min-width: 260px;
        }
        .flight-selector {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 13px;
            min-width: 180px;
        }
        .scan-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 13px;
            min-width: 200px;
        }
        .scan-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        #flight-list {
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #444;
        }
        .dual-slider {
            position: relative;
            width: 240px;
            height: 24px;
        }
        .dual-slider input[type=range] {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            pointer-events: none;
            -webkit-appearance: none;
            background: none;
        }
        .dual-slider input[type=range]::-webkit-slider-thumb {
            pointer-events: all;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #007bff;
            border: 2px solid white;
            box-shadow: 0 0 2px rgba(0,0,0,0.4);
            -webkit-appearance: none;
        }
        .dual-slider input[type=range]::-moz-range-thumb {
            pointer-events: all;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #007bff;
            border: 2px solid white;
            box-shadow: 0 0 2px rgba(0,0,0,0.4);
        }
        .dual-slider input[type=range]::-webkit-slider-runnable-track {
            height: 6px;
            background: linear-gradient(90deg, #0000ff, #8000ff, #ff0000, #000000);
            border-radius: 3px;
        }
        .dual-slider input[type=range]::-moz-range-track {
            height: 6px;
            background: linear-gradient(90deg, #0000ff, #8000ff, #ff0000, #000000);
            border-radius: 3px;
        }
        button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="info-panel">
        <span class="status">Click refresh to load</span>
        <div class="flight-selector">
            <label>Select Flight:
                <select id="flight-list" onchange="loadSelectedFlight()">
                    <option value="">-- All flights (live) --</option>
                </select>
            </label>
        </div>
        <div class="scan-controls">
            <span>Find flights in range (ft):</span>
            <div class="scan-row">
                <input id="alt-scan-min" type="number" min="0" max="75000" step="500" value="0" style="width: 100px; padding: 6px 8px; border: 1px solid #ccc; border-radius: 4px;">
                <span>-</span>
                <input id="alt-scan-max" type="number" min="0" max="75000" step="500" value="10000" style="width: 100px; padding: 6px 8px; border: 1px solid #ccc; border-radius: 4px;">
            </div>
            <button onclick="loadFlightsInRange()">Find & Draw</button>
        </div>
        <div class="range-filter">
            <div class="slider-row">
                <span>Altitude range (ft):</span>
                <span id="alt-values"></span>
            </div>
            <div class="dual-slider">
                <input id="alt-min" type="range" min="0" max="75000" step="500" value="0" oninput="onAltitudeChange()">
                <input id="alt-max" type="range" min="0" max="75000" step="500" value="75000" oninput="onAltitudeChange()">
            </div>
            <div class="slider-labels">
                <span>0</span>
                <span>20k</span>
                <span>40k</span>
                <span>60k</span>
                <span>75k</span>
            </div>
        </div>
        <button onclick="refreshMap()">Refresh</button>
    </div>

    <script>
        const BASE_URL = 'http://162.19.205.125:9002';  // Use relative URLs
        const API_URL = BASE_URL+'/locations.json';
        const FLIGHTS_URL = BASE_URL+'/flights/';
        const MAX_GAP_SECONDS = 600; // 10 minutes gap for connecting segments
        let map;
        let markers = [];
        let lastData = [];
        let minAlt = 0;
        let maxAlt = 75000;
        let polylines = [];
        let selectedFlightHex = null;

        function getMarkerRadius() {
            const zoom = map ? map.getZoom() : 2;
            if (zoom >= 15) return 5;
            if (zoom >= 11) return 3.5;
            if (zoom >= 6) return 2;
            return 1;
        }

        function getAltitudeColor(altitude) {
            // Gradient from blue (0) -> purple (20k) -> red (40k) -> black (60k+)
            const maxAlt = 75000;
            const norm = Math.min(altitude / maxAlt, 1); // normalize 0-1
            
            let r, g, b;
            if (norm < 0.267) { // 0-20k: blue to purple
                const t = norm / 0.267;
                r = Math.round(128 * t);
                g = 0;
                b = Math.round(255 - 128 * t);
            } else if (norm < 0.533) { // 20k-40k: purple to red
                const t = (norm - 0.267) / 0.266;
                r = Math.round(128 + 127 * t);
                g = 0;
                b = Math.round(128 - 128 * t);
            } else { // 40k-75k: red to black
                const t = (norm - 0.533) / 0.467;
                r = Math.round(255 - 255 * t);
                g = 0;
                b = 0;
            }
            
            return `rgb(${r}, ${g}, ${b})`;
        }

        function haversineKm(lat1, lon1, lat2, lon2) {
            const toRad = x => x * Math.PI / 180;
            const R = 6371; // km
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat/2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) ** 2;
            return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function initMap() {
            map = L.map('map').setView([20, 0], 2);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            map.on('zoomend', updateMarkerSizes);
        }

        function clearMarkers() {
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
        }

        function clearPolylines() {
            polylines.forEach(line => map.removeLayer(line));
            polylines = [];
        }

        function updateMarkerSizes() {
            const radius = getMarkerRadius();
            markers.forEach(marker => marker.setRadius(radius));
        }

        function onAltitudeChange() {
            const minInput = document.getElementById('alt-min');
            const maxInput = document.getElementById('alt-max');
            let minVal = parseInt(minInput.value, 10);
            let maxVal = parseInt(maxInput.value, 10);

            if (minVal > maxVal) {
                // keep knobs from crossing
                [minVal, maxVal] = [maxVal, minVal];
            }

            minAlt = minVal;
            maxAlt = maxVal;

            // reflect corrected values back to inputs
            minInput.value = minAlt;
            maxInput.value = maxAlt;

            const display = document.getElementById('alt-values');
            display.textContent = `${minAlt.toLocaleString()} - ${maxAlt.toLocaleString()} ft`;
        }

        function matchesAltitude(altitude) {
            return altitude >= minAlt && altitude <= maxAlt;
        }

        function formatTimestamp(ts) {
            const num = Number(ts);
            if (!Number.isFinite(num)) return 'N/A';
            const d = new Date(num * 1000);
            if (Number.isNaN(d.getTime())) return 'N/A';
            return d.toISOString();
        }

        function parseFlightListFromHtml(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const links = doc.querySelectorAll('a');
            const files = [];
            links.forEach(link => {
                const href = link.getAttribute('href');
                if (href && href.endsWith('.json')) {
                    files.push(href);
                }
            });
            return files.sort();
        }

        function buildSegmentsFromPositions(positions, hexTag = 'N/A') {
            const sortedKeys = Object.keys(positions).sort((a, b) => parseFloat(a) - parseFloat(b));

            const segments = [];
            let currentSegment = null;
            let pendingNull = [];

            const flushPending = (attachTo) => {
                if (!pendingNull.length) return;
                if (!attachTo) return;
                attachTo.points.push(...pendingNull);
                pendingNull = [];
            };

            sortedKeys.forEach(key => {
                const pos = positions[key];
                if (!pos.position || pos.position.length !== 2) return;
                const tsNum = parseFloat(key);
                if (!Number.isFinite(tsNum)) return;
                const [lat, lon] = pos.position;
                const altitude = pos.altitude || 0;
                const speed = pos.speed || 0;
                const track = pos.track || 0;
                const flight = (pos.flight || '').trim();
                const point = { lat, lon, altitude, speed, track, flight, ts: tsNum };

                if (!flight) {
                    pendingNull.push(point);
                    return;
                }

                if (pendingNull.length) {
                    if (currentSegment) {
                        const last = currentSegment.points[currentSegment.points.length - 1];
                        const gap = Math.abs(pendingNull[0].ts - last.ts);
                        if (gap <= MAX_GAP_SECONDS) {
                            flushPending(currentSegment);
                        } else {
                            pendingNull = []; // too long; do not connect
                        }
                    } else {
                        pendingNull = []; // no active segment to attach; drop
                    }
                }

                if (!currentSegment || currentSegment.flight !== flight) {
                    currentSegment = { flight, hex: hexTag, points: [] };
                    segments.push(currentSegment);
                }

                const lastPoint = currentSegment.points[currentSegment.points.length - 1];
                if (lastPoint) {
                    const gapToLast = point.ts - lastPoint.ts;
                    if (gapToLast > MAX_GAP_SECONDS) {
                        currentSegment = { flight, hex: hexTag, points: [] };
                        segments.push(currentSegment);
                    }
                }

                currentSegment.points.push(point);
            });

            if (pendingNull.length && segments.length) {
                const lastSeg = segments[segments.length - 1];
                const lastPt = lastSeg.points[lastSeg.points.length - 1];
                const gap = lastPt ? Math.abs(pendingNull[0].ts - lastPt.ts) : Infinity;
                if (gap <= MAX_GAP_SECONDS) {
                    lastSeg.points.push(...pendingNull);
                }
            }

            return segments;
        }

        function filterSegmentsByAltitude(segments, minBand, maxBand) {
            return segments
                .map(seg => {
                    const pts = seg.points.filter(p => p.altitude >= minBand && p.altitude <= maxBand);
                    return { ...seg, points: pts };
                })
                .filter(seg => seg.points.length > 0);
        }

        function drawSegments(segments, { fitBounds = false } = {}) {
            const before = markers.length;
            segments.forEach(seg => {
                const latlngs = [];
                seg.points.forEach(p => {
                    const color = getAltitudeColor(p.altitude);
                    const popupText = `<b>${(p.flight || 'N/A').trim()}</b> (${seg.hex || 'N/A'})<br>Time: ${formatTimestamp(p.ts)}<br>Position: ${p.lat.toFixed(4)}, ${p.lon.toFixed(4)}<br>Altitude: ${p.altitude.toLocaleString()} ft<br>Speed: ${p.speed} kts<br>Track: ${p.track}°`;
                    const marker = L.circleMarker([p.lat, p.lon], {
                        radius: 8,
                        fillColor: color,
                        color: color,
                        weight: 3,
                        opacity: 0.7,
                        fillOpacity: 0.6
                    }).bindPopup(popupText).on('click', function() { this.openPopup(); }).addTo(map);
                    markers.push(marker);
                    latlngs.push([p.lat, p.lon]);
                });

                if (latlngs.length > 1) {
                    const polyline = L.polyline(latlngs, {
                        color: '#0088ff',
                        weight: 3,
                        opacity: 0.6,
                        smoothFactor: 1.0,
                        pointerEvents: 'none'
                    }).addTo(map);
                    polylines.push(polyline);
                }
            });

            if (fitBounds && markers.length > before) {
                const group = new L.featureGroup(markers);
                map.fitBounds(group.getBounds().pad(0.2));
            }

            return { markersAdded: markers.length - before, segmentCount: segments.length };
        }

        function loadFlightsList() {
            fetch(FLIGHTS_URL)
                .then(response => response.text())
                .then(html => {
                    const selector = document.getElementById('flight-list');
                    const currentValue = selector.value;
                    selector.innerHTML = '<option value="">-- All flights (live) --</option>';
                    const files = parseFlightListFromHtml(html);

                    files.forEach(filename => {
                        const option = document.createElement('option');
                        option.value = filename.replace('.json', '');
                        option.textContent = filename;
                        selector.appendChild(option);
                    });
                    
                    selector.value = currentValue;
                })
                .catch(error => console.error('Error loading flights:', error));
        }

        function loadSelectedFlight() {
            const selector = document.getElementById('flight-list');
            const hex = selector.value;
            selectedFlightHex = hex;
            if (!hex) {
                refreshMap();
                return;
            }
            clearMarkers();
            clearPolylines();
            document.querySelector('.status').textContent = 'Loading flight...';
            fetch(`${FLIGHTS_URL}${hex}.json`)
                .then(response => response.json())
                .then(data => {
                    if (data.positions && Object.keys(data.positions).length > 0) {
                        const segments = buildSegmentsFromPositions(data.positions, hex);
                        drawSegments(segments, { fitBounds: true });
                        if (markers.length > 0) {
                            document.querySelector('.status').textContent = `${hex}: ${markers.length} positions across ${segments.length} segment(s)`;
                        }
                    } else {
                        document.querySelector('.status').textContent = 'No positions found';
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    document.querySelector('.status').textContent = 'Error loading flight';
                });
        }

        function renderMarkers(data) {
            clearMarkers();
            if (!Array.isArray(data) || data.length === 0) {
                document.querySelector('.status').textContent = 'No locations found';
                return;
            }

            const radius = getMarkerRadius();
            data.forEach(coord => {
                if (Array.isArray(coord) && coord.length >= 2) {
                    const [lat, lon, alt] = coord;
                    const altitude = alt || 0;
                    if (!matchesAltitude(altitude)) return;
                    const color = getAltitudeColor(altitude);
                    const marker = L.circleMarker([lat, lon], {
                        radius,
                        fillColor: color,
                        color: color,
                        weight: 1,
                        opacity: 0.7,
                        fillOpacity: 0.6
                    }).bindPopup(`${lat.toFixed(3)}, ${lon.toFixed(3)}<br>${altitude.toLocaleString()}ft`).on('click', function() { this.openPopup(); }).addTo(map);
                    markers.push(marker);
                }
            });

            if (markers.length > 0) {
                const group = new L.featureGroup(markers);
                map.fitBounds(group.getBounds().pad(0.1));
                updateMarkerSizes();
                document.querySelector('.status').textContent = `Loaded ${markers.length} locations`;
            } else {
                document.querySelector('.status').textContent = 'No locations in this filter';
            }
        }

        function loadLocations() {
            fetch(API_URL)
                .then(response => response.json())
                .then(data => {
                    lastData = Array.isArray(data) ? data : [];
                    renderMarkers(lastData);
                })
                .catch(error => {
                    console.error('Error:', error);
                    document.querySelector('.status').textContent = 'Error loading locations';
                });
        }

        function getScanRange() {
            const minInput = document.getElementById('alt-scan-min');
            const maxInput = document.getElementById('alt-scan-max');
            let minVal = Math.max(0, parseInt(minInput.value, 10) || 0);
            let maxVal = Math.max(0, parseInt(maxInput.value, 10) || 0);
            if (minVal > maxVal) [minVal, maxVal] = [maxVal, minVal];
            minInput.value = minVal;
            maxInput.value = maxVal;
            return { minVal, maxVal };
        }

        async function loadFlightsInRange() {
            const { minVal: scanMin, maxVal: scanMax } = getScanRange();
            selectedFlightHex = null;
            clearMarkers();
            clearPolylines();
            document.querySelector('.status').textContent = `Scanning flights ${scanMin.toLocaleString()} - ${scanMax.toLocaleString()} ft...`;

            let files = [];
            try {
                const html = await fetch(FLIGHTS_URL).then(r => r.text());
                files = parseFlightListFromHtml(html);
            } catch (err) {
                console.error('Error loading flight list:', err);
                document.querySelector('.status').textContent = 'Error loading flight list';
                return;
            }

            if (!files.length) {
                document.querySelector('.status').textContent = 'No flight files found';
                return;
            }

            let matchedFlights = 0;
            let scannedFlights = 0;

            const CONCURRENCY = 8; // fetch up to 8 files at a time
            let cursor = 0;

            const worker = async () => {
                while (true) {
                    const idx = cursor;
                    if (idx >= files.length) break;
                    cursor += 1;
                    const filename = files[idx];
                    scannedFlights += 1;
                    try {
                        const data = await fetch(`${FLIGHTS_URL}${filename}`).then(r => r.json());
                        if (!data.positions || !Object.keys(data.positions).length) continue;

                        const hexTag = filename.replace('.json', '');
                        const segments = buildSegmentsFromPositions(data.positions, hexTag);
                        let flightMin = Infinity;
                        let flightMax = -Infinity;
                        let hasInRange = false;
                        segments.forEach(seg => {
                            seg.points.forEach(p => {
                                const alt = p.altitude || 0;
                                flightMin = Math.min(flightMin, alt);
                                flightMax = Math.max(flightMax, alt);
                                if (alt >= scanMin && alt <= scanMax) {
                                    hasInRange = true;
                                }
                            });
                        });

                        // Only include flights with at least one point truly inside the band
                        if (hasInRange) {
                            const filteredSegs = filterSegmentsByAltitude(segments, scanMin, scanMax);
                            if (filteredSegs.length) {
                                drawSegments(filteredSegs);
                                matchedFlights += 1;
                            }
                        }
                    } catch (err) {
                        console.error(`Error loading ${filename}:`, err);
                    }

                    if (scannedFlights % 10 === 0) {
                        document.querySelector('.status').textContent = `Scanning... ${scannedFlights}/${files.length} files, found ${matchedFlights}`;
                    }
                }
            };

            const workers = Array.from({ length: CONCURRENCY }, () => worker());
            await Promise.all(workers);

            if (markers.length > 0) {
                const group = new L.featureGroup(markers);
                map.fitBounds(group.getBounds().pad(0.2));
            }

            document.querySelector('.status').textContent = `Flights within ${scanMin.toLocaleString()} - ${scanMax.toLocaleString()} ft: ${matchedFlights}/${files.length} (segments: ${polylines.length}, markers: ${markers.length})`;
        }

        function refreshMap() {
            document.querySelector('.status').textContent = 'Refreshing...';
            loadLocations();
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initMap();
            onAltitudeChange();
            loadFlightsList();
            document.querySelector('.status').textContent = 'Click refresh to load';
        });
    </script>
</body>
</html>
